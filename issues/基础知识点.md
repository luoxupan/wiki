## 流
**“流”又叫文档流，是css的一种基本定位和布局机制。** 流是html的一种抽象概念，暗喻这种排列布局方式好像水流一样自然自动。**“流体布局”是html默认的布局机制，如你写的html不用css，默认自上而下（块级元素如div）从左到右（内联元素如span）堆砌的布局方式。**

## 如何理解HTML语义化？

- 标题用h1，列表li标签（虽然都可用div实现效果
- 语义化的好处
  - 让人更易读懂（增加代码可读性）
  - 让搜索引擎更易读懂（SEO）

## 默认情况下，哪些HTML标签是块级元素，哪些是内联元素？

- 快状元素：block/table；有div、h1、h2、table、ul、ol、p 等
- 内联元素：inline/inline-block；有span、img、input、button 等


### inline内联特点：
- 只占据它对应标签的边框所包含的空间的元素。
- 这类元素如果父元素宽度足够则并排在一行显示。
- 元素的高度、宽度及顶部和底部边距**不可设置**。

### inline-block 特点：
- inline-block内联块状元素同时具备**内联元素**、**块状元素**的特点。
- 元素的高度、宽度、行高以及顶和底边距都可设置。

### block块级特点：
- 块级元素是指单独撑满一行的元素。每个块级元素都从新的一行开始，并且其后的元素也另起一行。
- 元素的高度、宽度、行高以及顶和底边距都可设置。
- 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。

### 替换元素：
替换元素是指内容可以替换的元素，实际上就是`content box`可以被替换的元素。如存在`src=""`属性的`<img> <audio> <video> <iframe>`元素和可以输入文本的`<input> <select> <textarea>`元素等。

所有替换元素都是内联元素，默认`display`属性是`inline`或`inline-block`（除了`input[type="hidden"]`默认`display: none;`）。

替换元素有自己默认的样式、尺寸（根据浏览器不同而不同），而且其`vertical-align`属性默认是`bottom`（非替换元素默认值是`baseline`）。

### attribute和property的区别？

# CSS

### css选择器优先级关系

!important > 内联样式 > ID选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器 > 通配符选择器

### link 标签和 @import 的区别

> 减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。

1. link 属于 html 标签，而 @import 是 css 提供的
2. 页面被加载时，link 会同时被加载，而 @import 引用的 css 会等到页面加载结束后加载
3. link 是 html 标签，因此没有兼容性，而 @import 只有 IE5 以上才能识别
4. link 方式样式的权重高于 @import

### margin padding 赋值为%百分比的时候，是按父元素的width为参照物
```html
<div class="payment-wrap">
  <div class="page-top-bg-img"></div>
</div>

.page-top-bg-img {
  width: 100%;
  padding-top: 66.66%; // 根据图片实际宽高换算
  background-image: url(//dpubstatic.udache.com/static/dpubimg/b29009d8-d301-45c3-8cfc-cae60624ff7e.png);
  background-size: cover;
  background-repeat: no-repeat;
}
```

### 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景

#### 结构：
display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，
visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击
opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击

#### 继承：
display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。
visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。

#### 性能：
displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大
visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容
opacity: 0 ： 修改元素会造成重绘，性能消耗较少

#### 相同点：它们都能让元素不可见

### rgba() 与 opacity 在透明效果上区别
- opacity 作用于元素，以及元素内的所有内容的透明度
- rgba() 只作用于元素的颜色或者背景色（设置rgba透明的元素的子元素不会继承透明效果）

## 布局
### 盒模型的宽度如何计算

> 盒模型的组成，由里向外content,padding,border,margin.

如下代码，请问div1的offsetWidth 是多大？
offsetWidth =（**内容宽度 + 内边距 + 边框**），无外边距
```html
<style>
  #div1 {
    with: 100px;
    padding: 10px;
    border: 1px solid #ccc;
    margin: 10px;
  }
</style>
<div id='div1'></div>
```
**答案是：** 122px

**_当div1的`box-sizing: border-box;`的时候是100px_**

> box-sizing的使用
```js
// CSS设置width的含义
box-sizing: content-box 是W3C盒子模型;width = content;
box-sizing: border-box 是IE盒子模型; width = content + border + padding;【content被改变，压缩】
```
box-sizing的默认属性是content-box
```
盒模型都是由四个部分组成的，分别是content、padding、border和margin。

标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的
范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。

一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。
```

### margin纵向重叠问题 
相邻元素的margin-top和margin-bottom会发生重叠

### margin负值问题
#### 对margin的top、left、right、bottom设置负值，有何效果？

- margin-top和margin-left负值、元素向上、向左移动
- margin-right负值，右侧元素左移，自身不受影响
- margin-bottom负值，下方元素上移，自身不受影响

### BFC理解和应用
#### 什么事BFC？如何应用它？

- Block format context，块级格式化上下文
- 一块独立渲染区域，内部元素的渲染不会影响边界以外的元素

#### 形成BFC的常见条件

- float不是none
- position是absolute或fixed
- overflow不是visible
- display是flex、inline-block等

#### BFC的常见应用

- 清除内部浮动（计算 BFC 的高度时，浮动元素也参与计算）
- 解决垂直和水平方向上 margin 重叠，一般设置 overflow:hidden

### float布局的问题，以及clearfix

#### 为什么需要清除浮动

如果一个父盒子中有一个子盒子，并且父盒子没有设置高，子盒子在父盒子中进行了浮动，那么将来父盒子的高度为0。由于父盒子的高度为0，下面的元素会自动补位，子盒子设置宽度父盒子撑不开，所以这个时候要进行浮动的清除。

#### 清除浮动: 触发BFC（Float，Overflow: Hidden，Display: Flex）
```html
<div class="parent" style="overflow:hidden">
  <div class="f"></div>
</div>
```

#### 清除浮动: clearfix
```html
<div class="clearfix">
  <div class="f"></div>
</div>
.clearfix:after {
  content: '';
  display: table;
  clear: both;
}
```

#### 清除浮动: 添加额外标签
```html
<div class="parent">    // 添加额外标签并且添加clear属性
  <div class="f"></div>
</div>
<div style="clear:both"></div>
```

### flex布局

- flex-direction 主轴方向
- justify-content 主轴方向上的对齐方式
- align-items  交叉轴对齐方式
- flex-wrap 是否换行
- align-self 单个项目 交叉轴对齐方式

**flex-grow**属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。

**flex-shrink**属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

**flex-basis**属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认
值为auto，即项目的本来大小。

flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。


## 定位
### absolute和relative分别依据什么定位

- relative相对本元素的左上角进行定位（相对于自身位置进行定位）,虽然经过定位后，位置可能会移动，但是本元素并没有脱离文档流，还占有原来的页面空间。
- absolute依据最近一层的定位元素定位（absolute、relative、fixed）找不到就body,绝对定位是脱离文档流的，与浮动定位是一样的效果，会压在非定位元素的上方。
- fixed(固定定位)相对于浏览器窗口进行定位

### 居中对齐有哪些方式
#### 水平居中

- inline元素：text-align: center;
- block元素：margin: auto;
- absolute元素：left: 50% + margin-left负值

#### 垂直居中

- inline元素：line-height的值等于height值
- absolute元素：top: 50% + margin-top负值
- absolute元素：transform: translate(-50%, -50%);
- absolute元素：top、left、bottom、right = 0 + margin: auto;

#### CSS 动画有哪些

animation、transition、transform、translate 这几个属性要搞清楚：

- animation：用于设置动画属性，他是一个简写的属性，包含6个属性
- transition：用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同
- transform：用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系
- translate：translate只是transform的一个属性值，即移动，除此之外还有 scale 等

## 响应式

### rem是什么--rem是一个长度单位

- px，绝对长度单位，最常用。
- em，相对长度单位，相对于父元素，不常用（如父10px，子1em表示10px大小）。
- rem，相对长度单位，相对于根元素，常用于响应式布局。
- vw/vh
  - vh网页视口高度的1/100
  - vw网页视口宽度的1/100
  - vmax取两者最大值；vmin取两者最小值

# JavaScript

## 声明和定义的区别
- 声明不会分配存储空间，只有定义时才会分配存储空间。

```js
var a; // 声明变量：不会被分配内存
a = 0; // 定义变量：定义就是分配了内存
```

## for...in 遍历的方式带来的情况

### The reason is that one construct:

``` js
var a = []; // Create a new empty array.
a[5] = 5;   // Perfectly legal JavaScript that resizes the array.

for (var i = 0; i < a.length; i++) {
  // Iterate over numeric indexes from 0 to 5, as everyone expects.
  console.log(a[i]);
}

/* Will display:
   undefined
   undefined
   undefined
   undefined
   5
*/
```

### can sometimes be totally different from the other:

``` js
var a = [];
a[5] = 5;
for (var x in a) {
  // Shows only the explicitly set index of "5", and ignores 0-4
  console.log(x);
}

/* Will display:
   5
*/
```

### Also consider that JavaScript libraries might do things like this, which will affect any array you create:

``` js
// Somewhere deep in your JavaScript library...
Array.prototype.foo = 1;

// Now you have no idea what the below code will do.
var a = [1, 2, 3, 4, 5];
for (var x in a){
  // Now foo is a part of EVERY array and 
  // will show up here as a value of 'x'.
  console.log(x);
}

/* Will display:
   0
   1
   2
   3
   4
   foo
*/
```

## 原型链继承
```js
function Person(name, age) {
  this.name = name,
  this.age = age,
  this.setAge = function () { }
}
Person.prototype.setAge = function () {
  console.log("111")
}

function Student(name, age, price) {
  Person.call(this,name,age)
  this.price = price
  this.setScore = function () { }
}
Student.prototype = new Person()
Student.prototype.constructor = Student // 组合继承也是需要修复构造函数指向的
Student.prototype.sayHello = function () { }

var s1 = new Student('Tom', 20, 15000)
var s2 = new Student('Jack', 22, 14000)
console.log(s1)
console.log(s1.constructor) // Student
console.log(p1.constructor) // Person
```

## [instanceof](https://github.com/ygxqqx/wiki/issues/19)

`instanceof` 运算符用于检测**构造函数**的 `prototype` 属性是否出现在**某个实例**对象的原型链上。
```js
[] instanceof Array // true
```

## 原型链，怎么不用instanceof知道一个对象的类型。

自从 ECMAScript 3 做出规定以后，就出现了确定某个对象是不是数组的经典问题。
对于一个网页，或者一个全局作用域而言，使用`instanceof`操作符就能得到满意
的结果：
 ```js
    if (value instanceof Array){
      //对数组执行某些操作
    }
 ```
  `instanceof` 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含
多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版
本的`Array`**构造函数**。如果你从一个框架向另一个框架传入一个数组，那么传入的
数组与在第二个框架中原生创建的数组分别具有各自**不同的构造函数**。

在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着**多个全局环境**，不同的全局环境拥有不同的全局对象，从而拥有**不同的内置类型构造函数**。这可能会引发一些问题。比如，表达式 `[] instanceof window.frames[0].Array` 会返回 `false`，因为` Array.prototype !== window.frames[0].Array.prototype`，并且数组从前者继承。

## 7 种数据类型: `Null`、`Undefined`、`Number`、`Boolean`、`String`、`Object`、`Symbol`

## typeof能判断哪些类型

- 能识别所有值类型
- 能识别函数
- 能判断是否是引用类型（不可再细分）

### 常见值类型
```js
let a                 typeof a // 'undefined'
const s = 'abc'       typeof s // 'string'
const n = 100         typeof n // 'number'
const b = true        typeof b // 'boolean'
const s = Symbol('s') typeof s // 'symbol'
```

### 使用`Object.prototype.toString.call()`，该方法返回类似`[object Type]`形式的字符串

### 常见引用类型
```js
const obj = {}   typeof obj // 'object'
const arr = []   typeof arr // 'object'
const n = null   typeof n   // 'object' 特殊引用类型，指针指向空地址
// 特殊引用类型，但不用于存储数据，所以没有“拷贝、复制函数”这一说
function fn() {} typeof fn  // 'function'
```
## 原型和原型链

- 每个class都有显示原型prototype
- 每个实例都有隐式原型__proto__
- 实例的__proto__指向对应class的prototype
- 基于原型的执行规则
  - 先在自身寻找属性和方法
  - 如果找不到则自动去__proto__中查找

## 正则表达式和replace
```js
function tranformMsg(string, keyword) {
  // var reg = /@\w+/g;
  var reg = new RegExp(`(@\\w+_${keyword}|@\\w+)`, 'g');
  var regReplaceFunc = function (match) {
    return `<a href='https://ddp.com/profile/${match}'>${match}</a>`
  };
  return string.replaceAll(reg, regReplaceFunc);
}
tranformMsg('@sds_4353ff_把九点半@nihao 第三方不仅是对', '把');
```

## 作用域和闭包
### 作用域

- 全局作用域
- 函数作用域
- 块级作用域（ES6新增）

### 自由变量

- 一个变量在当前作用域没有定义，但被使用了
- 向上级作用域，一层一层依次寻找，直至找到为止
- 如果到全局作用域都没找到，则报错 xx is not defined

### [闭包](https://zhuanlan.zhihu.com/p/22486908?refer=study-fe)
> 「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。

> [闭包的优点] 保存作用域，隔离环境
```js
var local = "变量";
function foo() {
  console.log(local);
}
```

## this为undefined的情况

严格模式下
```js
"use strict";
function foo() {
  console.log(this); // undefined
};
foo();
```

非严格模式
```js
function foo() {
  console.log(this); // Window 
};
foo();
```

## 箭头函数
- 箭头函数中的this是外部作用域的this,解决了之前要缓存this的弊端。

# 异步

- js是单线程语言，只能同时做一件事
- 浏览器和nodejs已支持js启动进程，如web worker
- js和DOM渲染共用一个线程，因为js可以修改DOM结构

### 应用场景

- 网络请求，如fetch
- 定时任务，如setTimeout

### 同步和异步的区别是什么

- 基于js是单线程语言
- 异步不会阻塞代码执行
- 同步会阻塞代码执行

## event loop（事件循环/事件轮询）
## async/await

- 解决异步回调
- async/await这哥俩个其实是 Promise 和 Generator 的语法糖。改变不了异步的本质，await后面的代码可以看做是异步内容
```js
async function async1(){
  console.log('async1 start');
  await async2();
  console.log('async1 end')
}
async function async2(){
  console.log('async2')
}
console.log('script start');
async1();
console.log('script end')
// 输出顺序：script start->async1 start->async2->script end->async1 end

// async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。
// 可以理解为，是让出了线程，跳出了 async 函数体。
async function func1() {
  return 1
}
console.log(func1()); // 返回是一个Promise
```

### 微任务/宏任务

同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；**异步任务**指的是，不进入主线程、而进入任务队列（task queue）的任务，只有等主线程任务执行完毕，**任务队列**开始通知主线程，请求执行任务，该任务才会进入主线程执行。

当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务；如果没有，在执行环境栈中会读取宏任务队列中排在最前的任务；执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。

`await`阻塞 后面的代码执行，因此跳出`async`函数执行下一个微任务

- 宏任务：setTimeout，setInterval，Ajax，Dom事件（addEventListener）
- 微任务：Promise.then，async/await
- 微任务执行时机比宏任务要早

### 什么是宏任务和微任务，两者有什么区别

- 宏任务：DOM渲染后触发，如setTimeout
- 微任务：DOM渲染前触发，如Promise

### setTimeout和setInterval

虽然使用setInterval()的定时动画比使用多个setTimeout()实现循环效率更高，但也 不是没有问题。无论setInterval()还是setTimeout()都是不能保证时间精度的。作为 第二个参数的延时只能保证何时会把代码添加到浏览器的**macrotask任务队列** ，不能保证添加到队列就会立即运行。如果队列前面还有其他任务，那么就要等这些任务执行完再执行。简单来讲， 这里毫秒延时并不是说何时这些代码会执行，而只是说到时候会把回调加到任务队列。如果添加到队列后，**主线程还被其他任务占用，比如正在处理用户操作，那么回调就不会马上执行**。

### [在浏览器中实现0ms延时的定时器](https://dbaron.org/log/20100309-faster-timeouts)

```js
(function() {
  var timeouts = [];
  var messageName = "zero-timeout-message";

  // Like setTimeout, but only takes a function argument.  There's
  // no time argument (always zero) and no arguments (you have to
  // use a closure).
  function setZeroTimeout(fn) {
      timeouts.push(fn);
      window.postMessage(messageName, "*");
  }

  function handleMessage(event) {
    if (event.source == window && event.data == messageName) {
      event.stopPropagation();
      if (timeouts.length > 0) {
        var fn = timeouts.shift();
        fn();
      }
    }
  }
  window.addEventListener("message", handleMessage, true);

  // Add the one thing we want added to the window object.
  window.setZeroTimeout = setZeroTimeout;
})();
```

### 最小延时 >=4ms

在浏览器中，setTimeout()/setInterval() 的每调用一次定时器的最小间隔是4ms，这通常是由于函数嵌套导致（嵌套层级达到一定深度），或者是由于已经执行的setInterval的回调函数阻塞导致的。

# [事件机制](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events)

事件三个阶段： **捕获阶段** ==> **目标阶段** ==> **冒泡阶段**

<img width="620" alt="bubble" src="https://luoxupan.github.io/img/bubble.png">

## 事件冒泡及捕获
### 在现代浏览器中，默认情况下，所有事件处理程序都在`冒泡阶段`进行注册。

> 如果您真的想在捕获阶段注册一个事件，那么您可以通过使用`addEventListener()`注册您的处理程序，并将可选的第三个属性设置为`true`。

当一个事件发生在具有父元素的元素上(例如，在我们的例子中是`<video>`元素)时，现代浏览器运行两个不同的阶段 - 捕获阶段和冒泡阶段。

![image](https://user-images.githubusercontent.com/7278711/126250525-52a71fbf-917a-4404-b16e-423a7158cd3f.png)


###  在捕获阶段：

- 浏览器检查元素的最外层祖先`<html>`，是否在捕获阶段中注册了一个onclick事件处理程序，如果是，则运行它。
- 然后，它移动到`<html>`中单击元素的下一个祖先元素，并执行相同的操作，然后是单击元素再下一个祖先元素，依此类推，直到到达实际点击的元素。

### 在冒泡阶段，恰恰相反:

- 浏览器检查实际点击的元素是否在冒泡阶段中注册了一个onclick事件处理程序，如果是，则运行它
- 然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达`<html>`元素。

### 演示：分别在body和div2中绑定click事件，用户点击div2时
```html
<body>
  <div id="div2">
    <p id="p5">取消</p>
    <p id="p6">取消</p>
  </div>
</body>
```
#### 冒泡时触发`目标事件`上面的事件
```js
document.body.addEventListener('click', (event) => {
  const target = event.target;
  console.log('body');
})
document.getElementById('div2').addEventListener('click', (event) => {
  const target = event.target;
  console.log('div2 clicked')
})
// 点击div2：先打印'div2 clicked'再打印'body'
```

#### 捕获时触发`目标事件`上面的事件
```js
document.body.addEventListener('click', (event) => {
  const target = event.target;
  console.log('body');
}, true)
document.getElementById('div2').addEventListener('click', (event) => {
  const target = event.target;
  console.log('div2 clicked')
})
// 点击div2：先打印'body'再打印'div2 clicked'
```
### 阻止默认行为

```js
event.preventDefault() // 阻止默认行为
// 比如a标签阻止默认行为就不会发生跳转
```

### 阻止冒泡
```js
event. stopPropagation();
// 事件不会向上传递
```

### 哪些事件是不会冒泡的

#### UI 事件

1. load 异步 不冒泡 ❌
2. unload 不冒泡 ❌
3. error 异步 不冒泡❌

#### Focus 事件
1. blur 不冒泡 ❌.     （失去焦点之后触发）
2. focus 不冒泡 ❌.  （获取焦点之后触发）

# 跨域

### 解决跨域的几种方式

- node后端代理
- nginx转发
- [CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)
    - 后端返回头加`Access-Control-Allow-Origin: *`
    - CORS当遇到`非简单请求`的时候会有[预检请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82)
    - 只要同时满足以下两大条件，就属于`简单请求`
        - 请求方法是以下三种方法之一
            - HEAD
            - GET
            - POST
        - HTTP的头信息不超出以下几种字段：
            - Accept
            - Accept-Language
            - Content-Language
            - Content-Type （值仅限于下列三者之一）
                - text/plain
                - multipart/form-data
                - application/x-www-form-urlencoded
- [jsonp](https://zhuanlan.zhihu.com/p/22600501?refer=study-fe)
``` js
var url = 'http://api.ygxqqx.com/weather.php?callback=__onGetData__';
window.__onGetData__ = function(ret) {
  console.log(ret);
}
function jsonp(url) {
  var script = document.createElement('script');
  script.src = url;
  document.head.appendChild(script);
  document.head.removeChild(script);
}
jsonp(url);
```

# Web Workers

通过使用Web Workers，Web应用程序可以在**独立于主线程的后台线程**中，运行一个脚本操作。这样做的好处是可以在独立线程中执行费时的处理任务，从而允许主线程（通常是UI线程）不会因此被阻塞/放慢。


# http
## http常见的状态码有哪些

### 状态码分类和常见状态码

- 1XX 服务器收到请求
- 2XX 请求成功
  - 200 成功
 - 3XX 重定向
   - 301 永久重定向（配合location，浏览器自动处理）-浏览器会记住 下次访问改网站直接用重定向的地址 网站改域名用到
   - 302 临时重定向（配合location，浏览器自动处理）-只是这次  不代表以后都重定向
   - 304 资源未被修改
 - 4XX 客户端错误
   - 404 资源未找到
   - 403 没有权限
 - 5XX 服务端错误
   - 500 服务器错误
   - 504 网关超时

### http常见的header有哪些
#### 常见的Request Headers
```
Accept: 浏览器可接收的数据格式
Accept-Encoding: 浏览器可接收的压缩算法，如gzip
Connection: keep-alive 一次TCP连接重复使用
User-Agent: 标识是浏览器信息
Cookie: 
Content-Type: application/json;charset=UTF-8 发送给后端数据格式 
```
#### 常见的Response Headers
```
Content-Type: application/json;charset=UTF-8 返回给前端的数据格式
Set-Cookie 
```
#### 缓存header
```
Cache-Control   Expires
Last-Modified   If-Modify-Since
Etag            If-None-Match
```
### 描述一下http的缓存机制

- 正常操作：地址栏输入URL、跳转链接、前进后退     强制缓存有效，协商缓存有效
- 手动刷新：command + R、点击刷新按钮     强制缓存失效，协商缓存有效
- 强制刷新：ctrl + F5     强制缓存失效，协商缓存失效

## 运行环境

- 运行环境即浏览器（server端有nodejs）
- 下载网页代码，渲染出页面，期间会执行若干JS
- 要保证代码在浏览器中稳定且高效

### 网页加载过程

#### 从输入URL到渲染出页面的整个过程

- 加载过程
  - DNS解析：域名 -> IP地址
  - 浏览器根据IP地址向服务器发起http请求
  - 服务器处理http请求，并返回给浏览器

- 渲染过程
  - 根据HTML代码生成DOM Tree
  - 根据CSS代码生成CSSOM
  - 将DOM Tree和CSSOM整合形成Render Tree
  -
  - 根据Render Tree渲染页面
  - 遇到<script>则暂停渲染，优先加载并执行JS代码，完成再继续
  - 直至把Render Tree渲染完成

## 性能优化

### 性能优化原则

- 多使用内存、缓存或其它方法
- 减少CPU计算，减少网络加载耗时

### 让加载更快

- 减少资源体积：压缩js、css，图片
- 缓存、强缓存，协商缓存
- 使用更快的网络CDN
- 开启gzip压缩
- 路由页面懒加载
- splitChunks提取公共第三⽅库
- Tree Shaking

### 让渲染更快

- CSS放在head，JS放在body下面
- 懒加载（图片懒加载，上滑加载更多）
- 对DOM查询进行缓存
- 频繁DOM操作，合并到一起插入DOM结构
- 节流throttle防抖debounce

## [CORB](https://www.chromestatus.com/feature/5629709824032768)
跨站请求头的MIME类型和返回的MIME类型不一样，会触发CORB保护。

例如：<script>标签跨站请求资源，返回头的MIME类型是json（真实内容是js代码只是MIME类型设置为json），此时分两种情况

1. 添加 ` 'X-Content-Type-Options': 'nosniff' ` 响应头（不让浏览器使用嗅探技术修正 MIME 类型）
2. 不添加 ` 'X-Content-Type-Options': 'nosniff' ` 响应头

**效果：** 跨域请求 js 文件时，如果没有设置 nosniff，甭管 MIME 类型设置了什么，都只是请求头不显示，响应头和响应结果正常显示。如果设置了 nosniff 且 MIME 类型不是 js，则会触发 CORB 保护，跨域 js 无法正常加载。

**解释：** 当跨域请求回来的数据 `MIME type` 同跨域标签应有的 `MIME` 类型不匹配时，浏览器会启动 `CORB` 保护数据不被泄漏，被保护的数据类型只有` html`、`xml` 和 `json`。很明显 `<script>` 和 `<img>` 等跨域标签应有的 `MIME type` 和 `html`、`xml`、`json` 不一样。

### 在非GitHub网站运行如下代码即可触发CORB
```js
var img = document.createElement('img');
img.src ='https://github.com/ygxqqx/wiki/issues'; // content-type: text/html; charset=utf-8
document.body.append(img);
```

### [简单请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82)

某些请求不会触发 **CORS 预检请求**。本文称这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：

### [window.requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)

`window.requestAnimationFrame() `告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

> 注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()

当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数(即你的回调函数)。回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。为了提高性能和电池寿命，因此在大多数浏览器里，当`requestAnimationFrame()` **运行在后台标签页**或者**隐藏**的`<iframe> `里时，`requestAnimationFrame()` 会被**暂停调用**以提升性能和电池寿命

## 安全

### 常见的web前端攻击方式有哪些

- XSS跨站请求攻击
  - 发表博客，其中嵌入<script>脚本（获取cookie等）
  - 窃取用户cookie信息、监听用户行为、修改DOM让用户输入敏感信息等等
  - 解决：替换特殊字符
      - httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。
      - secure-这个属性告诉浏览器仅在请求为https的时候发送cookie。

- CSRF跨站请求伪造 [链接](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)
  - CSRF的特点
       - 攻击一般发起在第三方网站（跨域），而不是被攻击的网站。被攻击的网站无法防止攻击发生。
       - 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。
       - 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
       - 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。
  - CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。
  - 向你发一封电子邮件，正文隐藏get接口的转账的请求
      -  `<img src="https://hacker.org/sendcoin?user=hacker&number=100">`
      - 当用户在登陆的状态下，点击该链接，这个图片自动加载并且发送一个请求，如果服务器没有做校验，那么请求就可成功。
  - 解决：
      - 接口增加验证码验证。
      - 设置Cookie的Samesite=Strict，当在第三方网站访问正常网站的接口是Cookie不可携带。
      - 验证来源站点--打开浏览器面板，会看到request header里面有referer和origin信息。
      - CSRF Token的防护策略。


## TCP的三次握手与四次挥手理解

### 三次握手

![image](https://user-images.githubusercontent.com/7278711/125256395-fdbdb080-e32e-11eb-9bb4-796bb02046a8.png)


### 四次挥手

![image](https://user-images.githubusercontent.com/7278711/125256455-09a97280-e32f-11eb-9478-78585bae6635.png)


### 为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

### 为什么不能用两次握手进行连接？

答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## Cookie有哪些属性
![image](https://user-images.githubusercontent.com/7278711/127733109-9111dd9e-7ee8-4b71-b5b8-68b78841fa65.png)


# ES6

## var、let、const异同

- `var`声明是**全局作用域**或**函数作用域**，而`let`和`const`是**块作用域**。
- `var`变量可以在其范围内**更新和重新声明**；` let`变量**可以被更新**但**不能重新声明**；` const`变量既不能更新也不能重新声明。
- 它们都被**提升**到其**作用域的顶端**。 但是，虽然使用变量`undefined`初始化了`var`变量，但未初始化`let`和`const`变量。
- 尽管可以在不初始化的情况下声明`var`和`let`，但是在声明期间必须初始化`const`。

